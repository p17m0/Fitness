# ACS MQTT API — Руководство для серверной стороны (Ruby)

Это документ описывает, как сервер должен взаимодействовать с устройством
ACS (Access Control System) по протоколу MQTT поверх TLS (MQTTS).

Документ предназначен для backend-разработчика с минимальным опытом.
Если ты не уверен, что делаешь — делай ровно так, как написано ниже.

----------------------------------------------------------------------
ОБЩАЯ АРХИТЕКТУРА
----------------------------------------------------------------------

ACS — это embedded-устройство (ESP32), которое:

- подключается к MQTT брокеру по TLS
- подписывается на control-топики
- принимает команды от сервера
- публикует логи и телеметрию
- НЕ хранит бизнес-логику
- сервер является единственным источником истины

Сервер:
- управляет токенами доступа
- выполняет полную синхронизацию токенов
- читает логи
- не делает предположений о состоянии устройства

----------------------------------------------------------------------
ТРАНСПОРТ И БЕЗОПАСНОСТЬ
----------------------------------------------------------------------

Протокол:
- MQTT v3.1.1
- Поверх TLS (MQTTS)

Аутентификация:
- TLS CA certificate (корневой сертификат)
- Client certificate
- Client private key
- Username + Password (дополнительно)

ВАЖНО:
Без корректных сертификатов устройство не подключится.
Без msg_id команды будут проигнорированы.

----------------------------------------------------------------------
ТОПИКИ (ВАЖНО)
----------------------------------------------------------------------

Все топики привязаны к ID устройства.

Базовый префикс:

    acs/<DEVICE_ID>/

Пример:

    acs/door-001/

----------------------------------------------------------------------
ДОПОЛНИТЕЛЬНЫЕ СООБЩЕНИЯ ОТ ACS (ESP -> СЕРВЕР)
----------------------------------------------------------------------

Устройство НЕ принимает решений.
Оно только:
- сообщает о событиях
- подтверждает команды
- сигнализирует о проблемах

Ниже — ПОЛНЫЙ список того, что ESP может отправить на сервер
на текущий момент.

----------------------------------------------------------------------
1) СОБЫТИЯ СКАНИРОВАНИЯ КАРТ
----------------------------------------------------------------------

Успешный доступ:

Topic:
    acs/<DEVICE_ID>/tele/log

Payload:
    {
      "ts": 1712345678,
      "event": "scan_granted",
      "reader": 1,
      "uid": "A1B2C3D4"
    }

Причины отказа:

    {
      "ts": 1712345678,
      "event": "scan_denied",
      "reader": 1,
      "uid": "A1B2C3D4",
      "reason": "time_invalid"
    }

Возможные reason:
- time_invalid        (нет корректного времени)
- door_busy           (дверь занята)
- ESP_ERR_NOT_FOUND   (токен не существует)
- ESP_ERR_INVALID_STATE (токен недействителен или resync)

ВАЖНО:
- сервер ОБЯЗАН логировать reason
- reason = строка из esp_err_to_name()

----------------------------------------------------------------------
2) HEARTBEAT КАРТОЧНОГО РИДЕРА
----------------------------------------------------------------------

Когда второй ESP (ридер) жив:

    {
      "ts": 1712345678,
      "event": "reader_heartbeat",
      "reader": 1
    }

Когда ридер пропал (таймаут):

    {
      "ts": 1712345678,
      "event": "reader_dead",
      "reader": 1
    }

Используй это для:
- алертов
- диагностики RS-485 / UART
- мониторинга hardware-faults

----------------------------------------------------------------------
3) СОБЫТИЯ КОНФИГУРАЦИИ
----------------------------------------------------------------------

Когда сервер прислал новую конфигурацию двери:

    {
      "ts": 1712345678,
      "event": "config_updated",
      "door_open_ms": 5000
    }

Если ты это видишь — конфиг применился успешно.

----------------------------------------------------------------------
4) СОБЫТИЯ RESYNC
----------------------------------------------------------------------

Когда устройство ВОШЛО в режим resync:

    {
      "ts": 1712345678,
      "event": "token_resync_begin"
    }

Когда устройство ПОЛУЧИЛО команду resync (лог сервера):

    {
      "ts": 1712345678,
      "event": "resync_requested"
    }

ВАЖНО:
- это лог, а не команда
- сервер сам решает, что делать дальше

----------------------------------------------------------------------
5) ОШИБКИ CONTROL-КОМАНД (NACK)
----------------------------------------------------------------------

Если команда пришла без msg_id:

    {
      "ts": 1712345678,
      "event": "ctrl_nack",
      "reason": "missing_msg_id",
      "topic": "acs/door-001/ctrl/token/add"
    }

Если msg_id есть, но команда не выполнена —
смотри ACK (см. раздел ACK).

----------------------------------------------------------------------
6) DEBUG ЛОГИ (ОПЦИОНАЛЬНО)
----------------------------------------------------------------------

Если включён CONFIG_ACS_MIRROR_LOGS_TO_MQTT:

Topic:
    acs/<DEVICE_ID>/tele/log_debug

Payload:
    обычная текстовая строка лога ESP-IDF

Пример:
    I (12345) reader_uart: Scan CRC mismatch

ВАЖНО:
- это НЕ JSON
- использовать только для отладки
- в проде нужно отключить

----------------------------------------------------------------------
7) OFFLINE СОБЫТИЕ (LAST WILL)
----------------------------------------------------------------------

Если устройство потеряло соединение с MQTT:

Topic:
    acs/<DEVICE_ID>/tele/log

Payload:
    {
      "event": "acs_offline"
    }

Это Last Will Message от брокера.

----------------------------------------------------------------------
ИТОГ
----------------------------------------------------------------------

ESP -> сервер:
- логи
- heartbeat
- события сканирования
- hardware / reader статус
- ACK / NACK
- запрос resync (request)

----------------------------------------------------------------------
TELEMETRY (устройство -> сервер)
----------------------------------------------------------------------

1) Логи

Topic:
    acs/<DEVICE_ID>/tele/log

Payload (JSON):
    {
      "ts": 1712345678,
      "event": "scan_granted",
      "reader": 1,
      "uid": "A1B2C3D4"
    }

Особенности:
- ts может быть null, если время ещё не синхронизировано
- формат JSON всегда однострочный
- сообщения могут приходить пачками

----------------------------------------------------------------------
2) Heartbeat

Topic:
    acs/<DEVICE_ID>/tele/heartbeat

Payload:
    {
      "ts": 1712345678,
      "uptime_ms": 12345678,
      "net": "up",
      "time_ok": true
    }

Используй это для:
- мониторинга онлайна
- определения проблем с временем
- алертов

----------------------------------------------------------------------
CONTROL (сервер -> устройство)
----------------------------------------------------------------------

ВСЕ control-сообщения ОБЯЗАНЫ содержать поле msg_id.

msg_id:
- строка
- уникальна в рамках запроса
- используется для ACK

----------------------------------------------------------------------
ACK (устройство -> сервер)
----------------------------------------------------------------------

Topic:
    acs/<DEVICE_ID>/ack

Payload:
    {
      "msg_id": "abc-123",
      "ok": true
    }

или

    {
      "msg_id": "abc-123",
      "ok": false,
      "reason": "ESP_ERR_INVALID_ARG"
    }

Если ACK не пришёл — считай команду не применённой.

----------------------------------------------------------------------
ТОКЕНЫ ДОСТУПА
----------------------------------------------------------------------

UID:
- 4 байта
- передаётся как HEX-строка (8 символов)
- пример: "A1B2C3D4"

Структура токена:

    {
      "uid": "A1B2C3D4",
      "valid_from": 1710000000,
      "valid_to":   1720000000,
      "day_start_s": 0,
      "day_end_s":   86399,
      "remaining_uses": 10,
      "version": 3
    }

Пояснения:
- valid_from / valid_to — UNIX UTC
- day_* — секунды от начала суток (UTC)
- remaining_uses:
    0           -> доступ запрещён
    UINT32_MAX  -> безлимит
- version — для отладки и контроля (не обязателен, но рекомендуется)

----------------------------------------------------------------------
ADD TOKEN
----------------------------------------------------------------------

Topic:
    acs/<DEVICE_ID>/ctrl/token/add

Payload:
    {
      "msg_id": "add-001",
      "uid": "A1B2C3D4",
      "valid_from": 1710000000,
      "valid_to": 1720000000,
      "day_start_s": 0,
      "day_end_s": 86399,
      "remaining_uses": 10,
      "version": 1
    }

Поведение:
- create или replace
- если токен уже есть — он перезаписывается

----------------------------------------------------------------------
UPDATE TOKEN
----------------------------------------------------------------------

Topic:
    acs/<DEVICE_ID>/ctrl/token/update

Payload:
    {
      "msg_id": "upd-001",
      "uid": "A1B2C3D4",
      "remaining_uses": 5,
      "version": 2
    }

Поведение:
- upsert
- отсутствующие поля остаются прежними

----------------------------------------------------------------------
REMOVE TOKEN
----------------------------------------------------------------------

Topic:
    acs/<DEVICE_ID>/ctrl/token/remove

Payload:
    {
      "msg_id": "del-001",
      "uid": "A1B2C3D4"
    }

----------------------------------------------------------------------
ПОЛНАЯ СИНХРОНИЗАЦИЯ ТОКЕНОВ (RESYNC)
----------------------------------------------------------------------

Это КРИТИЧЕСКИЙ механизм.

Используется когда:
- сервер перезапущен
- потеряно состояние
- массовое обновление

Устройство считает сервер АВТОРИТЕТОМ.

----------------------------------------------------------------------
RESYNC FLOW (ОБЯЗАТЕЛЬНО СОБЛЮДАТЬ ПОРЯДОК)
----------------------------------------------------------------------

1) BEGIN

Topic:
    acs/<DEVICE_ID>/ctrl/resync/begin

Payload:
    {
      "msg_id": "resync-begin-001"
    }

После этого:
- устройство блокирует доступ
- токены не расходуются
- начинается режим resync

----------------------------------------------------------------------
2) SEND ALL TOKENS

Отправь ВСЕ токены, которые должны существовать.
Используй token/add или token/update.

Если токен не будет отправлен — он будет УДАЛЁН.

----------------------------------------------------------------------
3) END

Topic:
    acs/<DEVICE_ID>/ctrl/resync/end

Payload:
    {
      "msg_id": "resync-end-001"
    }

После этого:
- устройство удалит все неупомянутые токены
- выйдет из resync
- снова разрешит доступ

----------------------------------------------------------------------
RESYNC REQUEST (устройство -> сервер)
----------------------------------------------------------------------

Topic:
    acs/<DEVICE_ID>/ctrl/resync/request

Payload:
    {
      "action": "request"
    }

Это означает:
- устройство просит сервер выполнить resync
- сервер должен инициировать BEGIN → TOKENS → END

----------------------------------------------------------------------
ПРИМЕР НА RUBY (MQTT)
----------------------------------------------------------------------

Используй gem:

    gem install mqtt

Пример:

    require "mqtt"
    require "json"

    MQTT::Client.connect(
      host: "broker.example.com",
      port: 8883,
      ssl: true,
      cert_file: "client.crt",
      key_file: "client.key",
      ca_file: "ca.crt",
      username: "acs",
      password: "secret"
    ) do |c|

      payload = {
        msg_id: "add-123",
        uid: "A1B2C3D4",
        valid_from: Time.now.to_i,
        valid_to: Time.now.to_i + 3600,
        day_start_s: 0,
        day_end_s: 86399,
        remaining_uses: 1,
        version: 1
      }

      c.publish(
        "acs/door-001/ctrl/token/add",
        payload.to_json,
        retain = false,
        qos = 1
      )
    end

----------------------------------------------------------------------
ВАЖНЫЕ ПРАВИЛА (НЕ НАРУШАТЬ)
----------------------------------------------------------------------

- Всегда жди ACK
- Никогда не отправляй команды без msg_id
- Resync — только BEGIN → TOKENS → END
- Не пытайся "угадывать" состояние устройства
- Если сомневаешься — делай resync

----------------------------------------------------------------------
КОНЕЦ ДОКУМЕНТА
----------------------------------------------------------------------

